---
export interface Props {
  constraints?: MediaStreamConstraints;
  stream?: MediaStream;
}

const url = import.meta.env.SUPABASE_URL;
const key = import.meta.env.SUPABASE_KEY;
---

<div class="video-mask">
  <!-- hidden -->
  <video
    id="localVideo"
    class="container-fluid"
    width="${window}.width"
    playsinline
    autoplay
    controls="false"
  >
  </video>
</div>
<video id="remoteVideo" autoplay playsinline></video>
<button
  id="ask-stream-perms"
  class="btn btn-primary"
  type="button"
  data-url={url}
  data-key={key}>Ask for permissions</button
>

<button id="callButton">call</button>
<button id="answerButton">answer</button>

<button id="hangupButton">hangup</button>
<input type="text" id="callInput" />

<!-- <script src="https://unpkg.com/@supabase/supabase-js@2"></script> -->

<script>
  // Create a single supabase client for interacting with your database
  // import supabase from "shared/libs/baas";
  const webcamButton = document.querySelector<HTMLButtonElement>(
    "button#ask-stream-perms"
  );

  import { createClient } from "@supabase/supabase-js";
  // console.log(webcamButton?.dataset.url);
  const urls: string[] = await fetch(
    "https://raw.githubusercontent.com/pradt2/always-online-stun/master/valid_hosts.txt"
  )
    .then((response) => response.text())
    .then((txt) => txt.split("\n"))
    .then((strArray) =>
      strArray
        .sort(() => 0.5 - Math.random())
        .slice(0, 2)
        .map((value) => "stun:" + decodeURI(value))
    );

  const pc = new RTCPeerConnection({ iceServers: [{ urls: urls }] });
  let localStream = new MediaStream();
  let remoteStream = new MediaStream();

  const supabase = createClient(
    webcamButton?.dataset.url,
    webcamButton?.dataset.key
  );

  pc.addEventListener("connectionstatechange", (event) => {
    if (pc.connectionState === "connected") {
      console.log("CONNECTED!!!!");
      // Peers connected!
    }
  });

  const localVideo =
    document.querySelector<HTMLVideoElement>("video#localVideo");
  const remoteVideo =
    document.querySelector<HTMLVideoElement>("video#remoteVideo");
  const callButton =
    document.querySelector<HTMLButtonElement>("button#callButton");
  const answerButton = document.querySelector<HTMLButtonElement>(
    "button#answerButton"
  );
  const hangupButton = document.querySelector<HTMLButtonElement>(
    "button#hangupButton"
  );
  const callInput = document.querySelector<HTMLInputElement>("input#callInput");

  webcamButton?.addEventListener("click", async () => {
    localStream = await navigator.mediaDevices.getUserMedia({
      video: true,
      // audio: true,
    });

    remoteStream = new MediaStream();

    // Push tracks from local stream to peer connection
    localStream?.getTracks().forEach((track) => {
      pc.addTrack(track, localStream);
    });

    // Pull tracks from remote stream, add to video stream
    pc.ontrack = (event) => {
      event.streams[0].getTracks().forEach((track) => {
        remoteStream.addTrack(track);
      });
    };

    if (localVideo) localVideo.srcObject = localStream;
    if (remoteVideo) remoteVideo.srcObject = remoteStream;

    if (callButton) callButton.disabled = false;
    if (answerButton) answerButton.disabled = false;
    webcamButton.disabled = true;
  });
  await supabase.removeAllChannels();

  const callDoc = supabase
    .channel("calls", {
      config: { broadcast: { self: true, ack: true } },
    })
    .subscribe((status) => console.log(status));
  const offerCandidates = (msg: object) =>
    callDoc.send({
      type: "broadcast",
      event: "ice",
      payload: { offer: msg },
    });
  const answerCandidates = (msg: object) =>
    callDoc.send({
      type: "broadcast",
      event: "ice",
      payload: { answer: msg },
    });

  // Reference Firestore collections for signaling
  // console.log(supabase.getChannels());
  // const channel = supabase.channel("sadAF", {
  //   config: { broadcast: { self: true, ack: true } },
  // });
  // channel.on("broadcast", { event: "offer" }, (payload) => {
  //   console.log("recieved", payload);
  // });
  // channel.subscribe((status) => {
  //   console.log(status);
  //   if (status === "SUBSCRIBED") {
  //     channel
  //       .send({
  //         type: "broadcast",
  //         event: "offer",
  //         payload: { x: Math.random(), y: Math.random() },
  //       })
  //       .then((status) => {
  //         if (status === "ok") console.log("ok");
  //         if (status === "timed out") console.log("timed out");
  //       });
  //   }
  // });

  callButton?.addEventListener("click", async () => {
    // program to generate random strings
    if (callInput && !callInput.value)
      callInput.value = Math.random().toString(36).substring(2, 7);
    // Get candidates for caller, save to db
    pc.addEventListener("icecandidate", (event) => {
      event.candidate &&
        offerCandidates({
          user: callInput?.value,
          data: event.candidate.toJSON(),
        }).then();
    });
    //----------------------------------------------------------------------------------
    // Create offer
    const offerDescription = await pc.createOffer();
    await pc.setLocalDescription(offerDescription);

    const offer = {
      sdp: offerDescription.sdp,
      type: offerDescription.type,
    };
    callDoc
      .send({
        type: "broadcast",
        event: "offer",
        payload: { user: callInput?.value, data: offer },
      })
      .then();

    // Listen for remote answer
    callDoc.on("broadcast", { event: "answer" }, async (payload) => {
      if (
        !pc.currentRemoteDescription &&
        callInput?.value === payload.payload.user
      )
        await pc.setRemoteDescription(
          new RTCSessionDescription(payload.payload.data)
        );
    });

    //----------------------------------------------------------------------------------
    // When answered, add candidate to peer connection
    callDoc.on("broadcast", { event: "ice" }, (payload) => {
      if (payload.answer) {
        console.log("payload.answer", payload.answer);
        console.log("payload.answer.user", payload.answer.user);
        console.log("payload.payload.answer", payload.payload.answer);
        console.log("payload.payload.answer.user", payload.payload.answer.user);
      }
      if (payload.answer && payload.answer.user === callInput?.value)
        pc.addIceCandidate(new RTCIceCandidate(payload.answer.data)).then();
    });

    if (hangupButton) hangupButton.disabled = false;
  });

  // 3. Answer the call with the unique ID
  answerButton?.addEventListener("click", async () => {
    // const callId = callInput?.value;

    pc.onicecandidate = async (event) => {
      event.candidate &&
        (await answerCandidates({
          user: callInput?.value,
          data: event.candidate.toJSON(),
        }));
    };
    //----------------------------------------------------------------------------------
    callDoc.on("broadcast", { event: "offer" }, async (payload) => {
      if (payload.payload.user === callInput?.value)
        pc.setRemoteDescription(
          new RTCSessionDescription(payload.payload.data)
        ).then();

      const answerDescription = await pc.createAnswer();
      await pc.setLocalDescription(answerDescription);

      const answer = {
        type: answerDescription.type,
        sdp: answerDescription.sdp,
      };
      callDoc
        .send({
          type: "broadcast",
          event: "answer",
          payload: { user: callInput?.value, data: answer },
        })
        .then();
    });

    //----------------------------------------------------------------------------------

    callDoc.on("broadcast", { event: "ice" }, (payload) => {
      if (payload.offer && payload.user === callInput?.value)
        pc.addIceCandidate(new RTCIceCandidate(payload.offer.data)).then();
    });
  });
</script>
<style>
  .video-mask {
    width: 350px;
    border-radius: 10px;
    overflow: hidden;
  }
</style>
